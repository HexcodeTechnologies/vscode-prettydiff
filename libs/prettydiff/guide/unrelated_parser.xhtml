<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Pretty Diff - Guide: How to write a parser</title>
        <link href="../css/index.css" media="all" rel="stylesheet" type="text/css" />
        <link
            href="http://prettydiff.com/guide/unrelated_dom.xhtml"
            rel="canonical"
            type="application/xhtml+xml" />
        <link
            href="http://prettydiff.com/images/favicon.ico"
            rel="icon"
            type="image/x-icon" />
        <link
            href="http://prettydiff.com/labels.rdf"
            rel="meta"
            title="ICRA labels"
            type="application/rdf+xml" />
        <meta content="width=device-width, initial-scale=1" name="viewport" />
        <meta content="index, follow" name="robots" />
        <meta content="Pretty Diff - Guide: How to write a parser" name="DC.title" />
        <meta
            content="(pics-1.1 'http://www.icra.org/pics/vocabularyv03/' l gen true for 'http://prettydiff.com' r (n 0 s 0 v 0 l 0 oa 0 ob 0 oc 0 od 0 oe 0 of 0 og 0 oh 0 c 1) gen true for 'http://www.prettydiff.com' r (n 0 s 0 v 0 l 0 oa 0 ob 0 oc 0 od 0 oe 0 of 0 og 0 oh 0 c 1))"
            http-equiv="pics-Label" />
        <meta content="Austin Cheney" name="author" />
        <meta
            content="Pretty Diff tool can minify, beautify (pretty-print), or diff between minified and beautified code. This tool can even beautify and minify HTML."
            name="description" />
        <meta content="Global" name="distribution" />
        <meta content="en" http-equiv="Content-Language" />
        <meta content="application/xhtml+xml;charset=UTF-8" http-equiv="Content-Type" />
        <meta content="blendTrans(Duration=0)" http-equiv="Page-Enter" />
        <meta content="blendTrans(Duration=0)" http-equiv="Page-Exit" />
        <meta content="text/css" http-equiv="content-style-type" />
        <meta content="application/javascript" http-equiv="content-script-type" />
        <meta
            content="qL8AV9yjL2-ZFGV9ey6wU3t7pTZdpD4lIetUSiNen7E"
            name="google-site-verification" />
    </head>
    <body class="white" id="prettydiff">
        <div class="contentarea" id="page">
            <section role="heading">
                <h1>
                    <svg
                        height="2000.000000pt"
                        id="pdlogo"
                        preserveAspectRatio="xMidYMid meet"
                        version="1.0"
                        viewBox="0 0 2000.000000 2000.000000"
                        width="2000.000000pt"
                        xmlns="http://www.w3.org/2000/svg">
                        <g
                            fill="#999"
                            stroke="none"
                            transform="translate(0.000000,2000.000000) scale(0.100000,-0.100000)">
                            <path
                                d="M14871 18523 c-16 -64 -611 -2317 -946 -3588 -175 -660 -319 -1202 -320 -1204 -2 -2 -50 39 -107 91 -961 876 -2202 1358 -3498 1358 -1255 0 -2456 -451 -3409 -1279 -161 -140 -424 -408 -560 -571 -507 -607 -870 -1320 -1062 -2090 -58 -232 -386 -1479 -2309 -8759 -148 -563 -270 -1028 -270 -1033 0 -4 614 -8 1365 -8 l1364 0 10 38 c16 63 611 2316 946 3587 175 660 319 1202 320 1204 2 2 50 -39 107 -91 543 -495 1169 -862 1863 -1093 1707 -568 3581 -211 4965 946 252 210 554 524 767 796 111 143 312 445 408 613 229 406 408 854 525 1320 57 225 380 1451 2310 8759 148 563 270 1028 270 1033 0 4 -614 8 -1365 8 l-1364 0 -10 -37z m-4498 -5957 c477 -77 889 -256 1245 -542 523 -419 850 -998 954 -1689 18 -121 18 -549 0 -670 -80 -529 -279 -972 -612 -1359 -412 -480 -967 -779 -1625 -878 -121 -18 -549 -18 -670 0 -494 74 -918 255 -1283 548 -523 419 -850 998 -954 1689 -18 121 -18 549 0 670 104 691 431 1270 954 1689 365 293 828 490 1283 545 50 6 104 13 120 15 72 10 495 -3 588 -18z" /></g>
                    </svg>
                    <a href="prettydiff.com.xhtml">Pretty Diff</a>
                    - Guide: How to write a parser</h1>
                <p id="dcolorScheme">
                    <label class="label" for="colorScheme">Color Scheme</label>
                    <select id="colorScheme">
                        <option>Canvas</option>
                        <option>Shadow</option>
                        <option selected="selected">White</option>
                    </select>
                </p>
                <p>Explore some
                    <a href="samples.xhtml">samples</a>
                    or browse
                    <a href="https://github.com/prettydiff/prettydiff">Pretty Diff on GitHub</a>.</p>
            </section>
            <section role="main">
                <h2>How to write a parser</h2>
                <div class="segment" id="doc_contents">
                    <h3>Table of Contents</h3>
                    <ol>
                        <li>
                            <a href="#purpose">Purpose</a>
                        </li>
                        <li>
                            <a href="#intro">Introduction</a>
                        </li>
                        <li>
                            <a href="#definitions">Definition of terms</a>
                        </li>
                        <li>
                            <a href="#pdway">Preferences, parsing the Pretty Diff way</a>
                        </li>
                        <li>
                            <a href="#howto">How to write a parser</a>
                            <ol>
                                <li>
                                    <a href="#howto-setup">Setup and get started</a>
                                </li>
                                <li>
                                    <a href="#howto-lexer">Write a lexer</a>
                                </li>
                                <li>
                                    <a href="#howto-structure">Define structures</a>
                                </li>
                                <li>
                                    <a href="#howto-useit">Use the parsed output</a>
                                </li>
                                <li>
                                    <a href="#howto-extend-theory">Extend the parser (in theory)</a>
                                </li>
                                <li>
                                    <a href="#howto-extend-practice">Extend the parser (in practice)</a>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#enjoyment">Enjoyment and fulfillment</a>
                        </li>
                    </ol>
                </div>
                <div class="segment" id="purpose">
                    <h3>Purpose</h3>
                    <p>This guide provides some basic introduction to terminology and techniques to
                        describe parsing applications and then follows up with a simple step by step
                        guide to write a parsing application. The scope of this guide is limited to
                        formal techniques to interpret computer languages and datasets. It does not
                        cover information related to compilation processes or tasks related to
                        application execution.</p>
                </div>
                <div class="segment" id="intro">
                    <h3>Introduction</h3>
                    <p>A parsing application merely provides the means of taking some input and
                        transforming it into works that computers can understand. The ability to write
                        parsers is to programming as the ability to write is to literacy, which is to
                        say that learning to write a simple parsing application opens new worlds of
                        instant capabilities. Some quick examples are a search engine spider, quickly
                        scraping relevant data out of a spreadsheet, analyzing financial data, or
                        quickly making sense of human language. The ability to understand and write
                        parsing applications will instantly transform any mediocre programmer into a
                        near rockstar.</p>
                    <p>The concepts, opinions, and theories expressed in this guide are universal to
                        programming. The methods and approaches are expressed according to JavaScript
                        language.</p>
                </div>
                <div class="segment" id="definitions">
                    <h3>Definition of terms</h3>
                    <ul>
                        <li>
                            <strong>abstract syntax tree (AST)</strong>
                            <p>An AST is a single organized body of output that describes tokens according
                                to descriptors provided by the parser in an organization that defines the
                                relationships of those tokens according the grammar(s) of the desired consuming
                                application. This is often a big object where each data facet is a token with
                                descriptions and child objects for each token as organized according to a
                                language grammar. This is the most common output format provided by parsers.</p>
                            <p>Here is an example of an AST generated by the
                                <a href="http://esprima.org/demo/parse.html">Esprima</a>
                                parser for the code:
                                <em>var answer = 6 * 7;</em>
                            </p>
                            <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li></ol><ol class='data'><li>{<em>&#xA;</em></li><li class='l0'>    "body"      : [<em>&#xA;</em></li><li class='l0'>        {<em>&#xA;</em></li><li class='l0'>            "declarations": [<em>&#xA;</em></li><li class='l0'>                {<em>&#xA;</em></li><li class='l0'>                    "id"  : {<em>&#xA;</em></li><li class='l0'>                        "name": "answer",<em>&#xA;</em></li><li class='l0'>                        "type": "Identifier"<em>&#xA;</em></li><li class='l0'>                    },<em>&#xA;</em></li><li class='l0'>                    "init": {<em>&#xA;</em></li><li class='l0'>                        "left"    : {<em>&#xA;</em></li><li class='l0'>                            "raw"  : "6",<em>&#xA;</em></li><li class='l0'>                            "type" : "Literal",<em>&#xA;</em></li><li class='l0'>                            "value": 6<em>&#xA;</em></li><li class='l0'>                        },<em>&#xA;</em></li><li class='l0'>                        "operator": "*",<em>&#xA;</em></li><li class='l0'>                        "right"   : {<em>&#xA;</em></li><li class='l0'>                            "raw"  : "7",<em>&#xA;</em></li><li class='l0'>                            "type" : "Literal",<em>&#xA;</em></li><li class='l0'>                            "value": 7<em>&#xA;</em></li><li class='l0'>                        },<em>&#xA;</em></li><li class='l0'>                        "type"    : "BinaryExpression"<em>&#xA;</em></li><li class='l0'>                    },<em>&#xA;</em></li><li class='l0'>                    "type": "VariableDeclarator"<em>&#xA;</em></li><li class='l0'>                }<em>&#xA;</em></li><li class='l0'>            ],<em>&#xA;</em></li><li class='l0'>            "kind"        : "var",<em>&#xA;</em></li><li class='l0'>            "type"        : "VariableDeclaration"<em>&#xA;</em></li><li class='l0'>        }<em>&#xA;</em></li><li class='l0'>    ],<em>&#xA;</em></li><li class='l0'>    "sourceType": "script",<em>&#xA;</em></li><li class='l0'>    "type"      : "Program"<em>&#xA;</em></li><li class='l0'>}<em>&#xA;</em></li></ol></div>
                        </li>
                        <li>
                            <strong>grammar</strong>
                            <p>A second set of rules, after syntax, to determine how parsed tokens come
                                together to form output that is intelligble to the consuming application. An
                                example is that syntax determines how to form words and sentences in human
                                written language, but grammar determines how those words and sentences come
                                together in a way that provides understandability.</p>
                        </li>
                        <li>
                            <strong>lexer</strong>
                            <p>A lexer is a utility that scans input looking for syntax rules in order to
                                organize the input into
                                <em>tokens</em>. The lexer will determine when a part of the input forms a code
                                comment, for example, and where that comment ends so as to begin something else.</p>
                        </li>
                        <li>
                            <strong>parallel array</strong>
                            <p>The term
                                <em>parallel array</em>
                                is a recognized computer science term that is used in this guide, but it is not
                                terminology commonly associated with parsing. Parallel arrays are a technique
                                for quickly populating data. This technique is similar to populating a
                            </p>
                        </li>
                        <li>
                            <strong>parser</strong>
                            <p>A parser is an analysis scheme to examine a list of tokens produced by a
                                lexer to determine a variety of qualities like: data types, token relationships,
                                validation, and other higher order qualities.</p>
                        </li>
                        <li>
                            <strong>parse table</strong>
                            <p>An alternative output format, compared to AST. Instead of arranging data in a
                                single giant object representing a tree of tokens a parse table outputs data in
                                a table. The parse tables formed by Pretty Diff and demonstrated in this guide
                                are formed using a technique called
                                <em>parallel arrays</em>.</p>
                            <p>This term should not be confused with an identical term used by the left
                                factorization compilation scheme. Please observe the following example of a
                                parse table generated by the Pretty Diff application for the code:
                                <em>&lt;a&gt;&lt;b&gt;sample text&lt;/b&gt;&lt;/a&gt;</em>
                            </p>
                            <table class="code">
                                <thead>
                                    <tr>
                                        <th>index</th>
                                        <th>attrs</th>
                                        <th>begin</th>
                                        <th>daddy</th>
                                        <th>jscom</th>
                                        <th>linen</th>
                                        <th>lines</th>
                                        <th>presv</th>
                                        <th>token</th>
                                        <th>types</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>0</td>
                                        <td>[]</td>
                                        <td>0</td>
                                        <td>"root"</td>
                                        <td>false</td>
                                        <td>1</td>
                                        <td>0</td>
                                        <td>false</td>
                                        <td>&lt;a&gt;</td>
                                        <td>"start"</td>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>[]</td>
                                        <td>0</td>
                                        <td>"a"</td>
                                        <td>false</td>
                                        <td>1</td>
                                        <td>0</td>
                                        <td>false</td>
                                        <td>&lt;b&gt;</td>
                                        <td>"start"</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>[]</td>
                                        <td>1</td>
                                        <td>"b"</td>
                                        <td>false</td>
                                        <td>2</td>
                                        <td>1</td>
                                        <td>false</td>
                                        <td>sample text</td>
                                        <td>"content"</td>
                                    </tr>
                                    <tr>
                                        <td>3</td>
                                        <td>[]</td>
                                        <td>1</td>
                                        <td>"b"</td>
                                        <td>false</td>
                                        <td>3</td>
                                        <td>1</td>
                                        <td>false</td>
                                        <td>&lt;/b&gt;</td>
                                        <td>"end"</td>
                                    </tr>
                                    <tr>
                                        <td>4</td>
                                        <td>[]</td>
                                        <td>1</td>
                                        <td>"b"</td>
                                        <td>false</td>
                                        <td>3</td>
                                        <td>1</td>
                                        <td>false</td>
                                        <td>&lt;/a&gt;</td>
                                        <td>"end"</td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <strong>syntax</strong>
                            <p>A fancy term that refers to the defining rule set to determine the expected
                                out. Syntax most commonly refers to the rules necessary to form a programming
                                language, but represent the bounds by which any lexer applies even if not to
                                form a programming language.</p>
                        </li>
                        <li>
                            <strong>token</strong>
                            <p>A token is an element of output formed from examining the input against a set
                                of rules.</p>
                        </li>
                        <li>
                            <strong>type</strong>
                            <p>A type, commonly referred to as a
                                <em>language data type</em>, is a categorical label for a given token. Some
                                common examples of data types are: string, comment, object, null, and number.</p>
                        </li>
                    </ul>
                </div>
                <div class="segment" id="pdway">
                    <h3>Preferences, parsing the Pretty Diff way</h3>
                    <p>In many parsing applications the lexer and parser are well separated
                        subjects. In the common approach a lexer scans an input and produces tokens for
                        the parser to analyze and the parser produces an AST for output. When the
                        applications are well optimized they can execute more than twice as fast as the
                        Pretty Diff approach, but there are limitations to this approach.</p>
                    <p>The parsers used in the Pretty Diff application combine the lexer and parser
                        into a single operation. The lexer scans the input looking for syntax and once a
                        token is identified it is immediately parsed before the lexer progresses
                        forward. This allows for advanced decisions, such as code correction and grammar
                        analysis, to occur immediately. These advanced features make the total execution
                        time of the parsing operation slower, which can make the Pretty Diff approach to
                        parsing appear more than twice as slow as other comparable parsers. Despite that
                        the Pretty Diff appeoach is substantially faster and more simple than attempting
                        to apply any such advanced analysis as a separate process outside the parser.</p>
                    <p>The Pretty Diff approach produces output in the form of parallel arrays
                        instead of an AST format. The idea is that an AST can be created from a parse
                        table approach provided one of the categories of data is structure and placement
                        information, but a parse table cannot be created from an AST without running
                        another parsing operation. The parse table approach also allows for sorting and
                        analysis by selectively targeting various areas and data types without
                        consideration for the output as a whole.</p>
                </div>
                <div class="segment" id="howto">
                    <h3>How to...</h3>
                    <div class="segment" id="howto-setup">
                        <h4>Setup and get started</h4>
                        <p>One of the primary reasons I prefer to write in JavaScript is because lambda
                            expressions are a native quality not hidden behind a convention. To get started
                            I prefer to write a function against a single global reference that contains
                            everything I need.</p>
                        <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li class='fold' title='folds from line 1 to line 5'>- 1</li><li>2</li><li>3</li><li>4</li><li>5</li></ol><ol class='data'><li>var <em class='s0'>myParser</em> = function (<em class='s1'>options</em>) <em class='s1'>{</em><em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>var <em class='s1'>token</em> = [],<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>types</em> = [],<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>parse</em> = function () <em class='s2'>{</em><em class='s2'>}</em>;<em>&#xA;</em></li><li class='l0'><em class='s1'>}</em>;<em>&#xA;</em></li></ol></div>
                        <p>In the above code sample we can see a single global variable,
                            <em>myParser</em>, that contains some declared variables. The references token
                            and types will store data while
                            <em>parse</em>
                            is a child function to store all the lexer/parser relevant instructions. This
                            will allow availability to the token and type data outside the
                            <em>parse</em>
                            function so that we can maintain separation of concerns and data availability
                            without having to pass things around. Now let's jump into the
                            <em>parse</em>
                            child function where we are going to write a simple lexer/parser.</p>
                    </div>
                    <div class="segment" id="howto-lexer">
                        <h4>Writing a lexer</h4>
                        <p>When writing a lexer I prefer to be as explicit as possible. The more
                            explicit the code the lower the risk of unexpected results. This means the code
                            will follow an imperative coding style. First, let's convert the input into a
                            string, if it isn't a string already, and then into an array that we can loop
                            through.</p>
                        <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li class='fold' title='folds from line 1 to line 9'>- 1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ol><ol class='data'><li>parse = function () <em class='s1'>{</em><em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>var <em class='s1'>data</em> = options.input<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .input<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .toString()<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .split(""),<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>len</em>  = <em class='s1'>data</em>.length,<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>a</em>    = 0;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>for (<em class='s1'>a</em> = 0; <em class='s1'>a</em> &lt; <em class='s1'>len</em>; <em class='s1'>a</em> += 1) {}<em>&#xA;</em></li><li class='l0'><em class='s1'>}</em>;<em>&#xA;</em></li></ol></div>
                        <p>Converting the input into an array is not required, but it makes things much
                            easier and faster to manipulate. Looping through a binary buffer, for instance,
                            can be more challenging to think through as humans don't read binary or
                            hexidecimal as fast as they read code and strings. Arrays are substantially
                            faster and more expressive to evaluate than large strings.</p>
                        <p>Using a
                            <em>for</em>
                            to iterate through an array is now considered an anti-pattern in JavaScript
                            since the ECMAScript5 version of the language provides a
                            <em>foreach</em>
                            method. I deliberately choose to use a for loop because there are times where it
                            is necessary to jump around to various indexes or iterate across the input
                            differently.</p>
                        <p>Now that we have the basic lexer written let's evaluate some syntax. We are
                            going to evaluate a C language styled block comment. A block comment begins
                            <em>/*</em>
                            and ends with
                            <em>*/</em>. To impose additional separation of concerns we will put this rule
                            behind another child function. First, lets create a rule and the child function:</p>
                        <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li class='fold' title='folds from line 1 to line 14'>- 1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ol><ol class='data'><li>parse = function () <em class='s1'>{</em><em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>var <em class='s1'>data</em>         = options.input<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .input<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .toString()<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        .split(""),<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>len</em>          = <em class='s1'>data</em>.length,<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>a</em>            = 0,<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>commentBlock</em> = function () <em class='s2'>{</em><em class='s2'>}</em>;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>for (<em class='s1'>a</em> = 0; <em class='s1'>a</em> &lt; <em class='s1'>len</em>; <em class='s1'>a</em> += 1) {<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    if (<em class='s1'>data</em>[<em class='s1'>a</em>] === "/" &amp;&amp; <em class='s1'>data</em>[<em class='s1'>a</em> + 1] === "*") {<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        <em class='s1'>commentBlock</em>();<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    }<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>}<em>&#xA;</em></li><li class='l0'><em class='s1'>}</em>;<em>&#xA;</em></li></ol></div>
                        <p>Now lets define the lexical analysis for a block comment:</p>
                        <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li class='fold' title='folds from line 1 to line 13'>- 1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li></ol><ol class='data'><li>commentBlock = function () <em class='s1'>{</em><em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>var <em class='s1'>comment</em> = [],<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>b</em>       = 0;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>for (<em class='s1'>b</em> = 0; <em class='s1'>b</em> &lt; len; <em class='s1'>b</em> += 1) {<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>comment</em>.push(data[<em class='s1'>b</em>]);<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    if (data[<em class='s1'>b</em>] === "/" &amp;&amp; data[<em class='s1'>b</em> - 1] === "*") {<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>        break;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    }<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>}<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>a = <em class='s1'>b</em>;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>token.push(<em class='s1'>comment</em>.join(""));<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>types.push("comment-block");<em>&#xA;</em></li><li class='l0'><em class='s1'>}</em>;<em>&#xA;</em></li></ol></div>
                        <p>A couple of things happened. We created a new reference
                            <em>b</em>
                            as a separate iterator. In this case the secondary iterator isn't needed and is
                            only present as an example that additional iterators can be used. Additional
                            iterators allow the freedom to traverse the data independently from the primary
                            iterator
                            <em>a</em>. If you choose to create an additional interator be sure to reassign
                            the value of the primary iterator before exiting the current function to avoid
                            duplicated effort.</p>
                        <p>At the end of this function we push a token, the entire block comment, and a
                            type. In this case we know the data type by knowing the syntax. This isn't
                            always the case. We won't know if a word is a language keyword or a user defined
                            reference without some additional effort. It is my opinion overall efficiency
                            increases by supplying these additional evaluations directly into the parser.
                            The additional tasks will always make the parser slower, which is wasted effort
                            if it isn't needed. Unfortunately, it is extremely diffecult to know what is or
                            isn't needed at parse time and performing these additional evaluations later,
                            after the parsing completes, is far more expensive still.</p>
                        <p>Here is what the combined code looks like:</p>
                        <div class='beautify' data-prettydiff-ignore='true'><ol class='count'><li class='fold' title='folds from line 1 to line 33'>- 1</li><li>2</li><li>3</li><li class='fold' title='folds from line 4 to line 30'>- 4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li class='fold' title='folds from line 12 to line 24'>- 12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li></ol><ol class='data'><li>var <em class='s0'>myParser</em> = function (<em class='s1'>options</em>) <em class='s1'>{</em><em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>var <em class='s1'>token</em> = [],<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>types</em> = [],<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>    <em class='s1'>parse</em> = function () <em class='s2'>{</em><em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>    var <em class='s2'>data</em>         = <em class='s1'>options</em><em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>            .options<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>            .input<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>            .toString()<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>            .split(""),<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>        <em class='s2'>len</em>          = <em class='s2'>data</em>.length,<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>        <em class='s2'>a</em>            = 0,<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>        <em class='s2'>commentBlock</em> = function () <em class='s3'>{</em><em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        var <em class='s3'>comment</em> = [],<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>            <em class='s3'>b</em>       = 0;<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        for (<em class='s3'>b</em> = 0; <em class='s3'>b</em> &lt; <em class='s2'>len</em>; <em class='s3'>b</em> += 1) {<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>            <em class='s3'>comment</em>.push(<em class='s2'>data</em>[<em class='s3'>b</em>]);<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>            if (<em class='s2'>data</em>[<em class='s3'>b</em>] === "/" &amp;&amp; <em class='s2'>data</em>[<em class='s3'>b</em> - 1] === "*") {<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>                break;<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>            }<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        }<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        <em class='s2'>a</em> = <em class='s3'>b</em>;<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        <em class='s1'>token</em>.push(<em class='s3'>comment</em>.join(""));<em>&#xA;</em></li><li class='l3'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>        <em class='s1'>types</em>.push("comment-block");<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em><em class='l2'>    </em>    <em class='s3'>}</em>;<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>    for (<em class='s2'>a</em> = 0; <em class='s2'>a</em> &lt; <em class='s2'>len</em>; <em class='s2'>a</em> += 1) {<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>        if (<em class='s2'>data</em>[<em class='s2'>a</em>] === "/" &amp;&amp; <em class='s2'>data</em>[<em class='s2'>a</em> + 1] === "*") {<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>            <em class='s2'>commentBlock</em>();<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>        }<em>&#xA;</em></li><li class='l2'><em class='l0'>    </em><em class='l1'>    </em>    }<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em><em class='l1'>    </em><em class='s2'>}</em>;<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em><em class='s1'>parse</em>();<em>&#xA;</em></li><li class='l1'><em class='l0'>    </em>return {token: <em class='s1'>token</em>, types: <em class='s1'>types</em>};<em>&#xA;</em></li><li class='l0'><em class='s1'>}</em>;<em>&#xA;</em></li></ol></div>
                    </div>
                    <div class="segment" id="howto-structure">
                        <h4>Define structures</h4>
                        <p>In addition to describing tokens by data type it is also frequently necessary
                            to describe them by the current structure in the application code. In markup
                            based languages there are parent elements and child elements, so a given
                            element's structure can be described by a parent element's tag name. In many
                            programming languages this distinction is less clear.</p>
                        <p>For languages that use a C language based syntax an easy way to think about
                            is in terms of matching start and end delimiters comprised of
                            <em>(</em>,
                            <em>{</em>,
                            <em>[</em>,
                            <em>&lt;</em>
                            and
                            <em>)</em>,
                            <em>}</em>,
                            <em>]</em>,
                            <em>&gt;</em>
                            respectively. The C language syntax family comprises JavaScript, Java, C#,
                            TypeScript, and many other languages. A structure is defined by the delimiter
                            character and context rules in a given language. For instance the
                            <em>[</em>
                            and
                            <em>]</em>
                            typically describe a list or array structure, but in C# it can also describe a
                            data type attribute given the context
                            <em>[</em>, word type, optional white space, and
                            <em>:</em>
                            (a colon). The easiest way to think about it is that you always know where you
                            are in parsing the code, what has already been parsed, and some idea of what is
                            coming. Always keeping that simple rule in mind helps prevent elaborate
                            conventions from distracting the simple ideas of parsing structures with
                            precision without guessing or rework.</p>
                        <p>Some structures allow context rules and conventions not permitted in other
                            various structures. It is helpful to describe structures during the initial
                            lexing and parsing process to allow decisions later without introducing an
                            additional parsing step. An example is that it may be desirable to identify
                            references, values, and their assignment with distinction which can vary in
                            syntax by the containing structure even within a single language.</p>
                        <p>Pretty Diff uses two arrays to define structures in its parsers. This keeps
                            the approach to structure consistent between the different parsers and allows
                            descriptions of hierarchy without need for an AST. The Pretty Diff parsers use
                            arrays named
                            <strong>depth</strong>
                            and
                            <strong>daddy</strong>
                            (in the case of markup) to describe the name of the current structure and an
                            array named
                            <strong>begin</strong>
                            that defines the token index where this structure started. Common values, in C
                            based syntax languages, for the depth array include but are not limited to:
                            <em>array</em>,
                            <em>function</em>,
                            <em>method</em>,
                            <em>class</em>,
                            <em>map</em>,
                            <em>object</em>,
                            <em>for</em>,
                            <em>if</em>,
                            <em>switch</em>. In the markup parser the depth array values take the tag name
                            of the parent element. From these arrays an AST or a DOM tree could be formed
                            without additional parsing considerations.</p>
                    </div>
                    <div class="segment" id="howto-useit">
                        <h4>Use the parsed output</h4>
                        <p>Once the parser completes the parallel arrays will be populated with data. It
                            is important that these parallel arrays always have the same number of indexes
                            and each index describes the data at that index of the token array. Knowing this
                            can save a lot of effort debugging failures later.</p>
                        <p>Since the output is merely a couple of arrays the data can be easily iterated
                            over. The data can also be examined by specific data types through examination
                            of the types array. Pretty Diff includes several additional parallel arrays for
                            describing qualities such as white space, markup attributes, markup parent
                            element, JavaScript code structure, and more. These additional arrays provide
                            data immediately without need for additional parsing steps.</p>
                        <p>One use example is navigating data structures. The jspretty and markuppretty
                            parsers both produce an array named
                            <em>begin</em>. Use this data to walk up the code structures or walk up markup
                            element hierarchy. The begin array stores the start index for a given code
                            structure so,
                            <em>begin[a]</em>, will return a number less than or equal to "a" indicating the
                            start type for the current structure where "a" is the index of any parsed token.
                            The number at
                            <em>begin[begin[a] - 1]</em>
                            would then contain the index for the next heigher structure start point. A small
                            loop could traverse this data to create an AST or walk up the DOM.</p>
                    </div>
                    <div class="segment" id="howto-extend-theory">
                        <h4>Extend the parser (in theory)</h4>
                        <p>A well written parser is extensible, which means additional supplimental
                            rules can be added later to allow new features at minimal collision with
                            existing features. Before a parser can be extensible it has to be sturdy and
                            confident in its current target language and conventions. The addition of new
                            rules, features, or even languages dramatically increases the risk of errors and
                            malformed output by the parser. Seek out diverse code examples and integrate
                            them into some form to test automation. Constantly seek to discover input that
                            will break the parser or output corrupted results. Once a corrupting code sample
                            is discovered ensure it is added to test automation as a test unit.</p>
                        <p>A general rule is to define data type names as specifically and precisely as
                            possible in the parser, perhaps even more specifically than the current need
                            demands. When writing a parser all the given edge cases and collisions of
                            various features of the target language likely aren't known. Unfortunately, many
                            of these edge cases will be discovered in production once error reports surface
                            from users. This is unfortunately true even for the most widely used of parsers.
                            Extreme care for precision, even when currently unnecessary, helps mitigate some
                            of these unknown errors.</p>
                        <p>Another general rule is to perceive the code in negatives, as in
                            <em>what can't or shouldn't be done</em>. Thinking about the code's decisions in
                            a more pessimistic view is a key way to limit risk by continously focusing on
                            predictable operations in the face of unknown and diverse input. This form of
                            thinking reenforces the idea that rules must be specific and not allow
                            deviations from a desired predictable state of output. As new features are added
                            think about them in terms of what they shouldn't do. The rules that define a new
                            feature will likely be simple, but ensuring their presence does not open
                            regression or complicate maintenance with extended complexity demands some
                            special care and discipline.</p>
                        <p>Since code parsing is comprised by a series of simple and mundane tasks with
                            the primary goals of sturdiness and performance plus a distant secondary goal of
                            extensibility the code tends to be rather boring. Imperative coding styles
                            appear to work best for this kind of work. The end result for the code author is
                            all about ensuring the code is as predictable as possible and contains the
                            fewest instructions possible. Fewer instructions means less code to maintain or
                            test (less developer time) and fewer things for the computer to evaluate
                            (performance).</p>
                    </div>
                    <div class="segment" id="howto-extend-theory">
                        <h4>Extend the parser (in practice)</h4>
                        <p>I recently extended Pretty Diff's JavaScript parser to support languages
                            Java, C#, and TypeScript. This extension required some additional work in the
                            beautifier, some additional structure descriptions, limiting use of automatic
                            semicolon insertion, support for new operators, and type annotations (type
                            generics). The big challenges were updating the beautifier to support new code
                            structures not present in JavaScript and parsing the type generics. For the
                            point of this discussion I will focus only upon adding the type generics
                            feature.</p>
                        <p>Type generics are angle brace delimited tokens similar in appearance to XML
                            tags. Type generics may contain a reference, a comma separated list of
                            references, and may contain a spread operator. They may also be nested so that
                            one type generic token contains another. Unlike XML tags type generics do not
                            contain attributes, end tags, or child nodes.</p>
                        <p>The complexity in this enhancement is ensuring it does not cause regression.
                            The JavaScript parser already provides support for the
                            <em>&lt;</em>
                            character as a less than operator and also as the start of an XML tag in the
                            case of React JSX language. The Pretty Diff parsers also don't limit support of
                            XML tags embedded within each other, which is required for the supported JSP
                            template language and could cause additional conflict. This enhancement would
                            allow a third and completely unrelated use for the less than character and it
                            must be added in a way that does not break support for the existing two uses.</p>
                        <p>This ehancement became easier when I realized that, aside from a TypeScript
                            only edge case, type generics would never exist in the same contexts as JSX's
                            XML tags. This reduced the complexity of the effort so that I only had to tell
                            the difference between whether the less than character reperesents a less than
                            operator or the start of a type generic token.</p>
                        <p>At this point in the lexing process you know exactly where you are and you
                            can look up the parsed tokens to see what has come before, but you don't know
                            what comes next in the code yet. Keeping this in mind I chose to presume the
                            token would be a type generic element opposed to a less than character until I
                            found reason to believe otherwise. If I did find evidence to believe this could
                            not be a type generic element I could easily return out of this logic and push a
                            less than operator into the token array and appropriate descriptions into the
                            other arrays because. This is especially simple since that operator is only one
                            character. I determined inappropriate evidence would be a character reserved for
                            operators or certain other syntax, a greater number of &gt; characters than &lt;
                            characters.</p>
                        <p>The case collision I hinted at earlier between TypeScript and React JSX in
                            whether these elements immediately follow a
                            <em>return</em>
                            keyword. In TypeScript you can return a type generic element from a function. In
                            React JSX you can return XML tags from a function. In this case I do not have
                            enough contextual information to tell the difference between whether this should
                            be an XML tag or a type generic element. To solve this problem I created a new
                            option to pass into the parser. If the language is assumed to be (or chosen by
                            the user) as TypeScript then an option named
                            <em>typescript</em>
                            is set to true, which prevents the parsing of XML tags from JavaScript like
                            code.</p>
                    </div>
                </div>
                <div class="segment" id="enjoyment">
                    <h3>Enjoyment and fulfillment</h3>
                    <p>Writing parsers isn't fun and exciting like writing the next hot video game.
                        It probably won't unlock the keys to the next major computer science
                        breakthrough. Writing parsers will, however, make you a better programmer.
                        Writing parsers will infuse in you a disciplined, conservative, and humble
                        approach to programming. It is often a thankless effort hidden beneath layers of
                        rules and utilities not visible to the end user. When you do well few people
                        will notice. When you break a user's code many will notice and few will forgive
                        you. Writing parsers is not the path to heroism.</p>
                    <p>I believe writing parsers has made me a better programmer in ways many other
                        programming disciplines could not. I believe I have learned qualities and
                        decisions that differ from many of my software developer peers because the goals
                        are different.</p>
                    <p>Application predictability is important. Unpredictable outputs often results
                        in harm. Helpful tooling and exciting or clever new conventions and features
                        won't make the code more predictable. The only things that make code more
                        predictable are fewer instructions, clearer flow control paths, separation of
                        concerns, and increased testing. The end result is boring stuff and code put on
                        a diet. Dieting in code is often, for many developers, an unacceptable
                        inconvenience much like dieting in real life.</p>
                    <p>You are on your own. There might be a team you can turn to help answer
                        questions, or an adviser to guide you through tough decisions, or there might
                        even be a helpful toolkit to assist with testing. None of those things will
                        solve hard problems for you. You will be forced to make decisions. Many of these
                        decisions could mean catastrophic failure that breaks a user's code. Many times
                        you won't have any idea. There isn't going to be a magical framwork out there to
                        make decisions for you. There is no solution in a box to write APIs for you or
                        manage expectations. You are on your own. You have to make hard decisions and
                        when you break a user's code, because it will happen, you have to own those
                        consequences and seek resolution.</p>
                    <p>Simplicity is different than easiness. Easy means lower developer effort for
                        the developer writing the code, but simplicity means less effort for everybody
                        else to include your users and the processing computer. These terms could not be
                        more different. The job of a competent developer is to make that distinction and
                        solve for it as directly as possible. Nobody will forgive you when you fail.
                        Your users will, however, recognize the additional effort to compensate for the
                        external failures around you if that means increased application dependability
                        or user fulfillment.</p>
                    <p>Superior programmers are simply people who iterate faster. There is no way to
                        know if you have solved a given problem until you have tested the solution. Once
                        the problem is solved you won't know if you have created additional problems or
                        regression issues without running additional tests. The pattern here is to
                        attempt a solution and then attempt to verify the solution against various
                        validations. The key to success is not some brilliant vision or the magic
                        ability to avoid failure. The key to success is simply speed. There is clearly
                        more to it than that, like a diversity of reliable test cases, but in the end it
                        always comes down to speed. The best way to think about this is that a developer
                        who works 10 times faster than the next developer is allowed to fail 10 times
                        more frequently before releasing code into production. The way to achieve
                        superior speed is to access the problems as directly as possible. Each barrier
                        between you and the problem will slow you down. Common barriers are too many
                        tools, abstractions, build processes, compile steps, frameworks, missing
                        documentation, unclear flow control, and so forth. Increased speed pays
                        unforeseeable compounded dividends over time as you learn to further increase
                        your speed with more precise forms of automation, organization, and planning.</p>
                    <p>Writing parsers is actually enjoyable and fulfilling. Over time you notice
                        that your discipline and development capabilities increase. Your speed
                        dramatically increases over time as each edge case can quickly consume large
                        portions of your life and mental health. Your ability to perceive large complex
                        problems before they occur and address them with simple elegant solutions is
                        something only you can appreciate, but it applies to many areas of life even
                        outside of software. Given enough practice your ability to write software
                        architectures seems to spotanously arise from nothing when really it is the
                        result of solving many tiny edge cases paired with a modest amount of planning.</p>
                </div>
            </section>
        </div>
        <script src="../lib/global.js" type="application/javascript"></script>
        <script src="../api/dom.js" type="application/javascript"></script>
    </body>
</html>
